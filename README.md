Hilbert Bases of Cuts
===========

A set of vectors 'S' in R^n is called a Hilbert bases if any vector that is in the cone and the lattice generated by S is also in the integer cone generated by S. Given a graph G, we can construct a set of vectors in R^E given by the characteristic vectors of cuts of G. It is an open question to determine for which graphs does this set form a Hilbert bases.

For detailed description, please have a look at my masters' thesis.
https://theses.lib.sfu.ca/thesis/etd7719

This repository consists of code written in C++ for calculating Hilbert bases of cuts of graphs using the Normaliz software. http://www.mathematik.uni-osnabrueck.de/normaliz/

For questions or comments, feel free to write to tanmaydesh5886@gmail.com


###Instructions:


1. matrix.txt is incidence matrix of graph.
Rows represent the edges and columns represent the vertices. If the adjacency matrix is available instead, convert to incidence matrix using adtoinc.cpp (Use in conjunction with GraphTea or other software that can generate the adjacency matrix of a graph).


2. use forloop.cpp to fill in code for cutgen.cpp. 
There should be as many nested for loops as the number of vertices of the graph. 


3. use cutgen.cpp to generate cuts.
Fill in correct values for a and b in cutgen.cpp. Compile and run cutgen.cpp -> outputs characteristic vectors of cuts into graph.in


4. Find Cone and Hilbert basis using Normaliz.
To use Normaliz, download the basic package and executables in the same folder. From the terminal go to the correct folder and type 
```
java -jar jNormaliz.jar
```
5. Open the file graph.in and run Normaliz with Hilbert basis mode (or higher).



###Extras:
If a graph G does not have Hilbert cuts, we need to analyse the vectors that are in the cone and the lattice but not in the integer cone of the cuts of G. We call such an element a 'quasi-Hilbert element of G'. To analyse such elements, we need to express them as a positive linear combination of cuts of G. The file lincomb.cpp does precisely this.


1. create a text file cuts.txt consisting of cuts of G. (copy-paste the the relevant lines from graph.in generated from cutgen.cpp)
2. fill in the values for a, b.
3. Compile and run to get graph.lp
4. Modify by adding quasi-Hilbert element in the first few constraints and fix display statement.
5. Solve lp (in this case, a constraint satisfaction problem) using glpk. From the terminal, go to the correct folder and type 
```
glpsol --math graph.lp -o out.txt
```    

6. Result will be stored in out.txt



###Future Updates:

Some ideas to be implemented in the near future. Feel free to try them yourself!

- Replace the annoying nested for-loops in cutgen.cpp with a more elegant recursion
- Integrate generation of cuts in GraphTea
- Integrate Normaliz calls in the cutgen.cpp


###References:

1. L. A. Goddyn, "Cones, lattices and Hilbert bases of circuits and perfect matchings", in Graph Structure Theory, Contemporary Mathematics 147 (1993), 419-439.

2. F. Lauberthe, "The Hilbert Basis of the Cut Cone over the Complete Graph K_6", in E. Balas and J. Clausen, eds., Integer Programming and Combinatorial Optimization, Lecture Notes in Computer Science, 
Vol. 920 (Springer, Berlin, 1995) 252-266.

3. M. Laurent, "Hilbert Bases of Cuts", Discrete Mathematics 150 Elsevier (1996) 257â€“279
